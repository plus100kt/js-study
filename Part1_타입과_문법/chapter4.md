# 4. 강제변환
강제변환의 좋고 나쁨을 충분히 이해하고 자신의 프로그램에 적절한지 판단할 수 있는 역량을 갖추어야한다.

## 4.1 값변환
어떤 값을 다른 값으로 바꾸는 과정이 명시적이면 타입 캐스팅, 암시적이면 강제변환이라고 한다. 타입캐스팅의 경우 정적언어에서 컴파일 시점에, 강제변환은 동적 타입언에서 런타임 시점에 발생한다. 이때 타입변환은 명시적 강제변환이라고 명칭되기도한다.

명시적 강제변환은 코드를 봤을때 의도적으로 타입변환을 일으키는 사실이 명백한 반면 암시적 강제변환은 다른 작업 도중 불분명한 부수 효과로부터 발생한다.
```js
var a = 42;
var b = a + ""; // 암시적 강제변환
var c = String( a ); // 명시적 강제변환
```

## 4.2 추상연산
어떻게 값이 문자열, 숫자, 불리언 등의 타입이 되는지 변환규칙을 알아보자

4.2.1 ToString

문자열이 아닌값 -> 문자열로 변환해주는 로직이다. 배열은 기본적으로 재정의된 toString()이 있다. 문자열 변환시 모든 원소 값이 콤마(,)로 분리된 형태로 이어진다.

JSON 문자열화

JSON은 JSON.stringify() 유틸리티를 이용하여 문자열화 할수있다.
* 문자열화 과정중 인자가 undefined, 함수, 심벌 값이면 자동으로 누락시키며 만약 배열에 포함되어 있으면 null로 바꾼다. 만약 객체 프로퍼티에 있으면 지워버린다.
* 부적절한 JSON값이나 직렬화하기 곤란한 객체 값을 문자열화하려면 toJSON() 메서드를 따로 정의해야한다.
* 이때 toJSON은 문자열화하기 적당한 JSON 안전값으로 바꾸는 것이지 문자열로 바꾸는 것이 아니다! 실제 문자열화는 JSON.stringify()가 담당한다.
```js
var o = { };

var a = {
    b: 42,
    c: o,
    d: function() {}
};

// 'a'를 환형 참조 객체로 만든다.
o.e = a;

// 환형 참조 객체는 JSON 문자열화 시 에러가 난다
// JSON.stringify(a);

// JSON 값으로 직렬화하는 함수를 따로 정의한다.
a.toJSON = function() {
    // 직렬화에 프로퍼티 'b'만 포함시킨다.
    return { b: this.b };
}

JSON.stringify( a ); // "{"b": 42}"
```

* JSON.stringify()의 세번째 인자는 들여쓰기해주는 스페이스 개수이다.

4.2.2 ToNumber
* true는 1, false는 0, undefined는 NaN, null은 0으로 바뀐다.
* 반환이 실패하면 결과는 NaN이 된다.
* 동등한 원시 값으로ㅠ 바꾸기 위해 ToPrimitive 추상 연산 과정에서 해당 객체가 valueOf() 메서드를 구현 했는지 확인한다. valueOf()를 쓸 수 있고 반환 값이 원시 값이면 그대로 강제변환하되, 그렇지 않을경우 toString()을 이용하여 강제 변환한다.
* 어찌해도 원시값으로 변환할 수 없을때는 typeError 오류를 던진다.

4.2.3 ToBoolean

다른 언어와 달리 숫자와 불리언은 독립적 관계로서 서로 다르다. 자바스크립트의 모든 값들을 불리언으로 변환할때 나타나는 유형은 둘중 하나이다.
1. 불리언으로 강제변환하면 false가 되는 값
2. 1번을 제외한 나머지(명백한 true깂)

이때 불리언으로 변환시 false가 되는 몇안되는 경우를 알면 좋다
* undefined, null, false, +0, -0, NaN, "" 이 경우들이 falsy한 값이다.
* falsy한 값을 감싼 객체는 모두 true이다.

하지만 위의 경우와 다르게 falsy 객체라는게 존재하는데 불리언으로 강제변환할 시 false가 되는 객체가 있다.
* document.all과 같은 코드는 예전 방식의 비표준이지만 많이 사용되어 왔기에 falsy하게 만들어 사용을 억제한다.

## 4.3 명시적 강제변환
분명하고 확실한 타입변환이다.

4.3.1 문자열 <-> 숫자

보통 String()과 Number() 함수를 이용해 강제변환하는 경우가 대다수 이지만, toString()과 + 단항 연산자를 이용해 명시적 강제변환을 하기도 한다.
```js
var a = 42;
var b = a.toString(); // String(a);

var c = "3.14";
var d = +c; // Number(c);

b; // "42"
c; // 3.14
```

날짜 -> 숫자
* +단항 연산자를 이용해 변경한다.
```js
var timstamp = +new Date();
```
* 강제변환을 하지 않아도 타임스탬프를 얻는 방법이 있는데 이 방법이 더 권장할만하다
```js
var timestamp = Date.now();
```

4.3.2 명시적 강제변환: 숫자 형태의 문자열 파싱

문자열로부터 숫자 값의 파싱은 비 숫자형 문자가 있더라도 숫자 같지 않은 문자를 만나면 멈추기에 사용할 수 있지만, 강제변환은 비 숫자형 문자를 허용하지 않기에 NaN을 반환합니다.

하지만 파싱은 강제변환과 목적이 다르기에 대안이 될 수 없다.
* 파싱하는법 parseInt(문자열) => 숫자형문자만 출력

4.3.3 명시적 강제변환: *->불리언

비불리언 -> 불리언 강제변환은 Boolean()을 이용한다.

# 4.4 암시적 변환
암시적 변환은 부수 효과가 명확하지 않기에 유해하고 위험하다고 취급되어지지만 중요한 부분으로부터 주의를 분산시키고 코드를 잡동사니로 채우는 불필요한 구현을 줄이기위해 사용된다.

4.4.2 암시적 강제변환: 문자열 <-> 숫자

+연산자는 '숫자의 덧셈, 문자열 접합' 두 가지 목적으로 오버로드된다.
```js
var a = "42";
var b = "0";

var c = 42;
var d = 0;

a + b; // "420"
c + d; // 42
```
d