# 5. 문법

## 5.1 문과 표현식

문(Statement)은 문장(Sentence), 표현식(Expression)은 어구(Phrase), 연산자는 구두점/ 접속사에 해당한다.

```js
var a = 3 * 6;
var b = a;
b;
```

- 각각의 줄은 표현식이 포함된 문이다.
- 1, 2번째 줄은 선언문(Declaration Statement)이다.
- a = 3 \* 6와 b = a는 할당 표현식(Assignment Expression)이다.
- 세번째 줄은 b가 표현식인 표현식문(Expression Statement)이다.

**5.1.1 문의 완료값**

모든 문은 완료 값을 가진다. 왜 문의 완료값을 알아야할까? 그것은 바로 완료값을 포착하야 값을 할당해야하는 경우가 생기기 때문이다. 이 완료값을 포착하려면 어쩔 수 없이 유해함의 대명사 eval() 함수를 사용한다.

```js
var a, b;
a = eval("if (true) { b = 4 + 38; }");
a; // 42
```

es7 버전 부터는 do 표현식을 이용해 완료값을 할당한다.

```js
var a, b;

a = do {
  if (true) {
    b = 4 + 38;
  }
};

a; // 42
```

- eval()은 되도록 사용하지말자!!

**5.1.2 표현식의 부수 효과**

```js
var a = 42;
var b = a++;
a;
43;
b;
42;
```

- ++ 연산자는 부수효과가 있는데 현재 값을 반환하고 1만큼 증가시키는 것이다. 그러므로 b는 현재값 42를 받환받고 a의 값을 1 증가시킨다. 이러한 부수효과를 캡슐화하기위해 ()를 사용하는건 의미가 없고 ,연산자를 사용해야한다.

```js
var obj = {
  a: 42
};

obj.a; // 42
delete obj.a; // true
obj.a; // undefined
```

- delete 연산자의 결과값은 유효한/허용된 연산일 경우 true, 그 외에는 false이고 부수효과로서 프로퍼티를 제거를 가진다.

- = 할당자도 부수효과를 일으키는데 할당 이후 실행값이 할당값이되는 부수효과를 가진다.

```js
functio vowels(str) {
    var matches;

    // 모든 모음을 추출한다.
    if (str && (matches = str.match(/[aeiou]/g))) {
        return matches;
    }
}

voweels("Hello World"); // ["e", "o", "o"]
```

- 할당 연산자의 부수효과를 잘 이용하면 위처럼 코드를 축약해 사용할 수 있다.

**5.1.3 콘덱스트 규칙**

자바스크립트 문법 규칙 중에는 같은 구문이지만 어디에서 어떤 식으로 사용하느냐에 따라 서로 다른 의미를 가지는 경우가 있다. 이중 몇가지 사례를 살펴보자

**중괄호**

자바스크립트에서 중괄호가 나올법한 곳은 크게 두군데이다.

1. 객체 리터럴
2. 레이블 - 레이블 점프를 프로그램 실행 흐름을 점프 시킬 수 있다.

```js
foo: for (var i = 0; i < 4; i++) {
  for (var j = 0; j < 4; j++) {
    if (j == i) {
      continue foo;
    }

    if ((j * i) % 2 == 1) {
      continue;
    }
    console.log(i, j);
  }
}
```

continue foo는 "foo라는 레이블이 붙은 루프의 다음 순회를 계속하라"는 뜻이다.

```js
foo: for (var i = 0; i<4; i++) {
    for (var j=0; j<4; j++) {
        if (i * j >=3)
        console.log("그만", i, j);
            break foo;
        }

        console.log(i, j);
    }
}
```

break foo는 "foo라는 레이블이 붙은 바깥쪽 루프/블록 밖으로 나가 그 이후부터 계속하라"는 의미이다.

위의 레이블 루프/블록은 사용 빈도가 극히 드물고 못마땅한 구석이 많아 가능한 한 피하는게 상책이지만 제한적으로 도움이 되는 경우가 없지 않으므로 레이블 점프를 사용할 경우 상세한 주석으로 잘 문서화 해야만한다.

**블록**

```js
[] + {}; // "[object Object]
{
}
+[]; // 0
```

- 윗줄에서 엔진은 + 연산자 표현식의 {}을 실제 값으로 해석한다. 4장 강제변환에서 설명했듯이 []는 ""로 강제변환되고 {}도 문자열 "[object Object]"로 강제변환한다.
- 아랫줄에서 {}는 빈 블록으로 간주되고 결국 + [] 표현식에서 명시적으로 []를 숫자 0으로 강제변환한다.

**객체 분해**

var { a, b } = ... 이 ES6의 분해 할당 형식이다.

```js
function foo({ a, b, c }) {
  console.log(a, b, c);
}

foo({
  c: [1, 2, 3],
  a: 42,
  b: "foo"
}); // 42 "foo" [1, 2, 3]
```

**else if와 선택적 블록**

많은 사람들이 else if라는 문법이 있다고 생각하지만 실제로는 다르게 처리된다. 하지만 관용적으로 허용되고 사용되는 표현이니 사용해도 나쁘지않다.

## 5.2 연산자 우선순위

- , 의 우선순위가 가장 낮다
- &&가 ||보다 우선순위가 높다.

**5.2.1 단락평가**

&&, || 연산자는 좌측 피연산자의 결과가 결정됨에 따라 전체 결과가 이미 결정될 경우 우측은 평가하지 않는다.

예를들어 &&의 좌측의 피연산자가 false면 전체결과는 false이고, || 좌측의 피연산자가 true이면 전체결과는 무조건 true이므로 더이상 평가할 필요가 없다.

```js
function doSomething(opts) {
  if (opts && opts.cool) {
    //...
  }

  if (opts.cache || primeCache) {
    //...
  }
}
```

- 첫번째 경우 opts가 존재하지 않는경우 opts.cool은 에러일 수 밖에 없지만 위의 표현식을 이용해 건너뛸 수 있다.
- 두전째 경우 opts.cache를 먼저 체크해서 ok면 primeCache() 함수는 호출하지 않고 넘어갈 수 있다.

**5.2.2 끈끈한 우정**

우선순위 - && > || > ? :

**5.2.3 결합성**

처리방향과 관계없이 좌측에서 혹은 우측에서 어디서 그룹핑이 일어나느냐에 따라 좌측 결합성 또는 우측 결합성을 가진다.

&&와 ||는 좌측부터 결합되는 좌측 결합성을 가진다. 하지만 이는 결과에 그다지 중요하지 않다. 하지만, 우측 결합성 연산자인 ?: 는 꼭 순서를 유념하고 계산해야만한다.

```js
a ? b : c ? d : e;
// 위를 우측 결합성에 따라 묶으면
a ? b : c ? d : e;

//직접해보자
true ? false : true ? true : true; // false
```

=도 또한 우측결합성이다. a = b = c = 42의 경우 a = (b = (c = 42))로 묶여 계산된다.

```js
var a = 42;
var b = "foo";
var c = false;
var d = a && b || c ? c || b ? a : c && b | a;
// d = ((a && b) || c) ? ((c || b) ? a : (c && b)) : a
d; // 42
```

- 위의 수식을 아래 주석처럼 묶는 연습을 해보자!

## 5. 3 세미콜론 자동 삽입

ASI는 행이 바뀔때마다 ;이 빠져 에러가 나면 ;을 삽입해줍니다. 예를 들어 while, for과 달리 do while 문법의 경우 끝에 ;을 삽입해야 하지만 실수로 누락 하는 경우가 많다. 이때 ASI가 대신 삽입해줍니다.

**5.3.1 에러 정정**

ASI덕분에 몇몇 경우(for( ; ; ) 같은 경우)를 제외하고는 ;는 선택사항이 된다. 하지만 ;이 없는 문장은 엄연히 문법적으로 잘못된 경우이고 이러한 경우 전체적인 코드가 아름답지 못할 가능성이 크다.

## 5.4 에러

런타임 시점에 적용되는 하위 에러 타입과 달리 일부 에러는 컴파일 시점에 발생한다.
정규 표현식 리터럴 내부 구문과 할당대상의 위치, 함수 인자명 중복 등이 이에 해당한다.

```js
var a = /+foo/; // 에러!

var b;
42 = b; // 에러!

function bar(a, b, a) { "use strict;" } // 에러
```

**5.4.1 너무 이른 변수 사용**

ES6부터는 초기화가 되지 않아 변수를 참조 할 수 없는 코드 영역인 TDZ라는 개념을 도입했다.

```js
{
  a = 2; // ReferenceError
  let a; // TDZ에 있는 a값을 참조할 수 없다.
}
```

## 5.5 함수 인자

TDZ 관련 에러는 ES6 디폴트 인자 값에서도 찾아볼 수 있다.

```js
var b = ;
function foo(a = 42, b = a+1) {
    console.log( a, b );
}
```

함수 인자에서 b는 바깥쪽이 아닌 tdz에 남아있는 b를 참조하려하기에 에러가 난다.

argument를 이용하여 함수 인자값을 추출할때 인자 값이 입력이 안되면 default값이 반환되는게 아니라 undefinded가 반환됩니다.
그러므로 ES6 이후부터는 argument보다 rest를 사용하도록 권장하고 있습니다.

## 5.6 try...finally

fanally 절의 코드는 반드시 실행되고 다른 코드로 넘어가기 전에 try 이후부터 항상 실행된다. 어떤의미에서 finally 절은 다른 블록 코드에 상관없이 필히 실행되어야 할 콜백 함수와 같다고 봐야 맞다.

```js
function foo() {
  try {
    throw 42;
  }
  finally {
    console.log("hello");
  }

  console.log("실행될리 없지");
}
console.log(foo()); //42 hello
```

return 42에서 함숫값은 42로 세팅되고 try절의 실행이 종료되며 finally 절로 넘어간다.

return처럼 continue, break, throw도 비슷하게 동작한다.
* return 이 여러개 있으면 그 중에 finally return을 가장 우선시 한다.

## 5.7 switch

switch case 구문에 있어서 모를만한 부분이 정리되어있다.
1. switch 표현식과 case 표현식 간의 매치 과정은 === 알고리즘과 똑같다.
* 그러나 강제변환이 일어나는 동등비교(==)를 사용하고 싶다면 switch에 몇가지 작업이 필요하다.
```js
var a = "42";
switch(true) {
  case a == 10:
    console.log("10 또는 '10'");
    break;
  case a == 42:
    console.log("42 또는 '42'");
    break;
  default:
    // 여기 올일 없다
}
```

2. ==를 사용하더라도 비교연산자를 사용할때 문제가 생긴다.
```js
var a = "Hello world";
var b = 10;
switch (true) {
  case a (a || b == 10):
    break;
  default:
    console.log("어이쿠"); 
} 
// 어이쿠
```
* 평가는 truthy 하지만 결과는 true가 아니므로 매치가 되지 않는다.

